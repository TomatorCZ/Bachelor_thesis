\chapter{Solution}

This chapter describes the complete solution, solving the use cases.
We start with an overview of the solution parts.
Then, we give a detailed description of each part.
\par
The solution consists of four projects, which will form the resulting Blazor website containing PHP scripts.
In Figure \ref{img13:infrastructure}, we can see these projects as green rectangles.
The \textit{Server} project references \textit{Blazor App}, containing a part of the website, and \textit{Peachpie.Blazor}, containing an additional support code.
A part of the support code is a Javascript script, which is linked to at the beginning of \texttt{index.html}, providing helper functions for form handling and interoperability with PHP.  
The server cares about serving the Blazor website and its Static Web Assets.
The next project is our library containing an API for including PHP scripts to the website.
There are \texttt{PhpComponent} and \texttt{PhpScriptProvider}, mentioned earlier, together with additional code support necessary for the correct functionality.
There is the Blazor App project, which becomes the environment for running PHP scripts in a browser.
The project references \textit{PHP scripts} and \textit{Peachpie.Blazor}, which content is used to maintain PHP scripts.
We can see the user's defined scripts as .NET project compiled by Peachpie in \textit{PHP scripts}.
\textit{Blazor App} injects the scripts using the components.
\par
The first section aims at \texttt{PhpComponent}.
It introduces the implementation problems connected to creating render demanding applications and solves them.
The second section talks about \texttt{PhpScriptProvider}.
It suggests a convenient way how to include the scripts into a browser, and it presents the component design.
The last section aims at the server settings.
\par
\begin{figure}[!b]\centering
\includegraphics[scale=0.9]{./img/SolutionInfrastructure}
\caption{The solution infrastructure. Green rectangles represent projects. Arrows represent a references.}
\label{img13:infrastructure}
\end{figure} 

\section{PhpComponent}

In the beginning, we introduce problems, which are related to the \textit{PhpComponent} use case.
Then, we suggest a solution and design \texttt{PhpComponent} class.
\par
The first problem causes PHP, which does not know structs and method overloading.
Structs are necessary to work with \texttt{RenderTreeBuilder}, which contains API for adding callbacks handling element events, as we can see in Figure \ref{img14:callback}.
This API uses method overloading in many methods.
\texttt{AddAttribute} is an example where we can write various types of the attribute value.
One of the values can be \texttt{EventCallback} struct representing an event handler.
The struct contains static property \texttt{Factory}, which is a class containing methods for creating callbacks.
\par
\begin{figure}
\begin{lstlisting}
__builder.OpenElement(5, "button");
__builder.AddAttribute(7, "onclick", 
		EventCallback.Factory.Create<MouseEventArgs>((object)this, 
				(Action)IncrementCount));
__builder.AddContent(8, "Click me");
__builder.CloseElement();
\end{lstlisting}
\caption{Fragment of code adding a button element with an event handler.}
\label{img14:callback}
\end{figure}
\par
Peachpie enables using structs in PHP code. 
However, there are limitations at the time of writing, which force us to make workarounds.
We try to rewrite the previous example in PHP code using Peachpie.
We create a component, which inherits {textttComponentBase}. 
Afterward, we override the method for building a render tree and implements the body.
The fragment of the body can be seen in Figure \ref{img15:problems}, where we try using workarounds to make the example functional.
There is the first issue in line 5, where Peachpie does not allow us to access a static property of struct.
It results in a runtime error, which can be solved by \texttt{Helper} written as a C\# class containing a method, which returns the property.
The second issue causes method overloading when Peachpie can not choose the correct version of the \texttt{Create} method in line 8.
Peachpie defines a type of PHP function, \texttt{IPhpCallable}, which can cause the issue
However, if we wrap this function into the correct type by a helper function, the problem remains.
The workaround can be another helper method, which will have a different name for each overload of this method.
However, we come to a compilation error when we want to get an instance of \texttt{EventCallback}.
As we can see in the figure, we tried to use many workarounds, but it is impossible to use some Blazor structures directly in PHP code.
\par
\begin{figure}
\begin{lstlisting}[numbers=left]
use \Microsoft\AspNetCore\Components;
...
$builder->OpenElement(1, "button");
		
//$factory = Components\EventCallback::Factory;
$factory = \ClassLibrary2\Helper::GetFactory();

//$action = function() {\System\Console::WriteLine("Click");}; 
$action = \ClassLibrary2\Helper::GetAction(function() {
	\System\Console::WriteLine("Click");});
		
//$callback = $factory->
//	Create<Components\Web\MouseEventArgs>($this, $action);
$callback = \ClassLibrary2\Helper::
	GetCallback<Components\Web\MouseEventArgs>($factory, 
		$this, $action);

$builder->AddAttribute(2, "onclick", $callback);
$builder->AddContent(3, "Click me");
$builder->CloseElement();
\end{lstlisting}
\caption{Problem of using structs and method overloading. Helper is a class defining workarounds.}
\label{img15:problems}
\end{figure}
\par
To make the example functional, we can hide the struct from PHP code by implementing a C\# helper method using the struct.
The method should have only parameters compatible with PHP types. 
The overloading can be replaced by a different method name for each overload.
Afterward, Peachpie allows us to call the methods from PHP code.
We can use this approach in the \texttt{AddAtribute} method. 
Defining a new method for each overload is a reasonable approach due to a small number of overloads.
Although defining global methods are not the best way, how to do it.
It is a pity that the builder is sealed. 
Although, we can create a wrapper containing the builder and defining method for each overload, which calls the original method in C\# code.
This decision leads us to make a new \texttt{RenderTreeBuilder}  in a different namespace as a wrapper of the original builder.
\par
The next issue relates to rendering time.
\texttt{RenderTreeBuilder} provides a method for adding arbitrary markup text.
The text can contain \texttt{<script>}, but its content is not executed.
At first glance, one can see the method as a convenient way to render the whole content, avoiding using other dedicated methods for building the tree.
These methods accept a sequence number used by the diff algorithm. 
Although using the one method for rendering, the whole component causes slow rendering, which is critical in some applications like games.
The diff algorithm relies on marking the blocks of markup by sequence numbers for optimization in page updates.
When we have only one big block, the diff algorithm can not do anything better than generate an update, which renders the whole page. 
This issue can be seen in the Benchmark section, where we compare the difference between using the one method and utilizing all methods.
Because the builder usage can be complex, we introduce a library for representing tags, helping implement the code using the builder for rendering.
We present library class diagram in Figure \ref{img16:diagram}.
The main idea is to implement the \texttt{iBlazorWritable} interface, which writes the class content into the builder.
An example of a class is \texttt{Tag}, which represents an arbitrary tag.
Because a tag can contain other tags using sequence numbers, we have to keep the currently used sequence number used in the diff algorithm.
For this purpose, the \texttt{writeTreeBuilder} method gets the actual sequence number and returns the last unused number.
This API should hide separated class logics for rendering.
We offer the basic implementation of this method, which renders the content with a dynamic sequence numbering. 
However, a programmer can override the method because sequence numbering is impossible to predefine in advance to make the most effective updates.
Another abstraction is \texttt{AttributeCollerction}, which offers convenient interface for working with attributes by implementing PHP \texttt{ArrayAccess}.
\par
\begin{figure}\centering
\includegraphics[scale=0.8]{./img/ComponentLibrary}
\caption{Class diagram of supporting library for writting tags.}
\label{img16:diagram}
\end{figure} 
\par
The next barrier is assigning handlers to C\# events in PHP code.
Peachpie does not either support accessing the events.
Thus, we can not directly use a class like \texttt{Timer}, which is useful in \textit{PhpComponent} use case for updating the screen every period.
The issue can be solved by helper methods defined in C\# accepting the object, handler, and event name.
Afterward, we can use reflection for obtaining the desired event by name from the object and then assign the \texttt{IPhpCallable} handler to it.
Because \texttt{Timer} is a common object, we create an additional PHP wrapper class, which uses the timer.
Then a programmer avoids to use the workaround defined above.
\par
\begin{figure}\centering
\includegraphics[scale=0.8]{./img/PhpComponentSolution}
\caption{Class diagram of the use case solution.}
\label{img17:solution}
\end{figure}
\par
The last feature to discuss in this section is interoperability between Javascript and PHP.
We can utilize a Blazor service,\texttt{IJSRuntime}, injected by the dispatcher, to call Javascript functions.
The service offers a specialized API for that.
Calling PHP from Javascript is more complex.
Peachpie enables calling PHP function by \texttt{Call} method of \texttt{Context}. 
The context finds already defined methods contained in the included PHP script and executes it with the current context.
When we want to call C\# instance method from Javascript, we have to have the reference, supplied by the framework, for calling it.
Additionally, the called C\# method has to be marked with a \texttt{JSInvokableAttribute} during compilation.
The reference can be assigned from C\# by a method, which creates it and uses it as a parameter of a Javascript function.
These conditions lead us to create our context,\texttt{BlazorContext}, which inherits the original context and provides the \texttt{CallPHP} method marked by the attribute and calling the PHP function based on parameters.
The context requests the mentioned services provided by the dispatcher and sets the reference by calling predefined code in \texttt{Peachpie.Blazor.js}.
The context will be the Peachpie context of the component.
Thus, it enables to call PHP methods defined in this context from Javascript by using the reference.
However, it has a limitation.
Calling PHP functions is allowed when the reference is presented, meaning that we have to create the context and include scripts containing the functions.
The advantage of this approach is that we can have two components inheriting \texttt{PhpComponent} with the same context when we set their context to the same instance.
Thus, we can call their functions by only one reference.
\par
When we already presented the problems, we can introduce the architecture of \texttt{PhpComponent} and solution of \textit{PhpComponent} use case.
The component hides the original function for rendering and replaces it with our version of the builder, as shown in Figure \ref{img17:solution}.
It results in transparent usage of the builder in the inherited class.
The builder is just a wrapper, so the programmer can use the original builder by accessing its property.
Additional, there is a library for creating tags, which should make the builder usage easier.
For assigning PHP handlers to C\# events, there is a universal helper.
Furthermore, the last feature is a timer wrapper, which uses the C\# timer, offering a convenient API.
For the interoperability, we can use our predefined API using \texttt{BlazorContext}.
\par
The last necessary thing is to get assembly references containing the components to \texttt{Router}, which is a standard duty in Blazor.
\section{PhpScriptProvider}

At the beginning of this section, we introduce the main component parts, which gives us an overview of the component composition.
We divide component duties like navigation or script execution into subsections because the component consists of many processes, which are complex to describe at once in the structure.
The component functionality should be explained in these sections.
\par
\begin{figure}[b]\centering
\includegraphics[scale=0.8]{./img/PhpScriptProvider}
\caption{Diagram illustrating usage of PhpScriptProvider main parts.}
\label{img18:provider}
\end{figure}
\par
We start with Figure \ref{img18:provider} describing the connections between the main parts.
\texttt{PhpScriptProvider} is a class, representing a Blazor component.
The component manages the following features.
It handles the navigation.
It finds the script by name based on provider mode.
It creates and keeps a PHP context, which is used for script execution.
It executes the script.
These duties contain several steps, which are maintained by the parts.
As we can see, there is \texttt{PhpComponentRouteManager}, which finds the components, inheriting \texttt{PhpComponent}, based on \texttt{RouteAttribute}.
It enables navigation of Blazor components defined in PHP scripts.
The next part is \texttt{BlazorContext} already mentioned in PhpComponent, which is Peachpie \texttt{Context} designed for Blazor enviroment.
The context constructor accepts several Blazor services like \texttt{IJSRuntime} enabling interoperability with Javascript.
The context initializes superglobals based on URL and submitted forms, manages files uploaded by a form, and controls  \texttt{BlazorWriter} which redirects the script output to the render tree.
In the end, \texttt{FileManager} reads submitted files, downloads them, or deleting them from Browser memory.
\par
We zoom in on \texttt{PhpScriptProvider} structure in order to prepare a context for explaining the feature functionalities.
The provider consists of many properties.
Some of them are injected by the dispatcher like \texttt{NavigationManager} or \texttt{IJSRuntime}, which is a service providing interoperability with Javascript.
Others can be parametrized, like \texttt{Type} determining the mode of provider, \texttt{ContextLifetime} determining the persistency of the script context, or \texttt{ScriptName} determining the executing script when the mode \textit{Script} is set.
These properties influence the component methods.
The first method is \texttt{Attach}, which assigns a render handle providing \texttt{RenderTreeBuilder}, and registers a navigation handler creating the context and calling \texttt{Refresh}.
The second method,\texttt{SetParameters}, cares about calling \texttt{Refresh}, and creating the context as well.
\texttt{Refresh} finds a script or a component based on properties, assigns the superglobals, and calls \texttt{Render} which renders the component or executes the script.
\texttt{OnAfterRender} cares about enabling the forms to send data back to Blazor.
Some of these methods are called by Blazor framework providing the component lifecycle.

\subsection{Navigation}

Now, we explain navigation in \texttt{PhpScriptProvider} for each its mode.
We have to clarify how the component is instantiated and maintained by Blazor.
There are two ways how to use the component.
The first of them is to set it in \texttt{WebAssemblyBuilder} as a root component,
which is rendered after the first application launch in Blazor.
The component is alive for the whole application life because there is no \texttt{Router}, which disposes components representing a previous page. 
It results in calling the \texttt{Attach} method and the \texttt{SetParameters} method only once.
The second way is to use a Razor page containing the component and let the navigation to the page on \texttt{Router}, which is a root component by default.
When the page is navigated, the component is instantiated as well.
The difference is the possibility of calling the \texttt{SetParameters} method multiple times when the page is parameterized.
Then, when the parameters are changed, Blazor automatically calls the inner component \texttt{SetParameters} methods when the components have no primitive types. 
This fact is because the Blazor framework can not decide if the parameters, which are complex types, were changed.
\par
The \textit{Router} mode is designed to be used when the component is a root component.
Then we are sure, that \texttt{Attach} and \texttt{SetParameters} methods are called only once.
Thus, we register navigation handler in the \texttt{Attach} method, which should handle further navigation.
When the navigation occurs, we create a new context if the context should not be persistent and call \texttt{Refresh}.
We create a new context and call \texttt{Refresh} method in \texttt{SetParameters} as well, which can be problematic with its multiple calling, but in this case, it is all right.
Then the \texttt{Refresh} method parses the query part of URL, obtained from \texttt{NavigationManager} and gets the script name from the URL.
When we determine the script name, we call the \texttt{Render} method, where we decide if it is a script or a component defined in a script based on \texttt{.php} extension.
If the extension is missing, we try to find a component defined in scripts, which has correct \texttt{RouteAttribute} by \texttt{PhpComponentRouteManager}.
Additional manager duty is to assign assembly references containing scripts, to the context, at the beginning of the application.
Otherwise, we ask the Peachpie context for obtaining the script representation as \texttt{ScriptInfo}.
The context does not have to know the script name, or the component does not have to exist. 
Then we render predefined \textit{not found} page, which can be set by \texttt{PhpScriptProvider} parameters.
Otherwise, we render the script or the component.
Additionally, when we navigate the component, we set its context by our context.
It results in using the interoperability by either provider or the component because we can use the same context reference in Javascript code.
\par
Next modes, \textit{ScriptProvider} and \textit{Script}, are similar.
They are defined in a Razor page and initialized when the page is navigated.  
The difference is finding the script by name, where the \textit{Script} always uses the name defined in the component parameter and \textit{ScriptProvider} finds script based on URL.
As we said, the \texttt{SetParameters} can be called multiple times, so we call \texttt{Refresh} only by the first time in the method.
Additional rendering is initiated by the navigation handler.
Thus, when the navigation occurs, we find and update the page, or we are disposed if the \texttt{Router} match another Razor page. 
We should check if the component has not already been disposed by \texttt{Router} before calling the \texttt{Refresh}.
Obtaining the script is similar to \textit{Router} mode.

\subsection{Script Execution}
We start with \texttt{BlazorWriter}, which inherits \texttt{TextWriter}.
The inheritance allows using the writer as \texttt{BlazorContext} output writer, which manipulates with script output.
The writer consists of a buffer and \texttt{RenderTreeBuilder}.
The main usage is to write any string to the writer, which adds it to the buffer.
In the end, the writer flushes it into the builder by \texttt{AddMarkUpContent}.
It results in treating the whole script output as one modification by diff algorithm, which causes the whole page update instead of smaller necessary updates.
This disadvantage relates to the following limitations.
\texttt{AddMarkUpContent} does not allow to add incomplete markup text, meaning that tags are not properly closed.
Thus, we can not divide the text into smaller parts because of the HTML nature, where tags are coupled by other tags.
The second possibility is to parse the output and recognize the types of HTML entities, which can use specialized builder API.
However, it is not suitable because of parser complexity.
It is important to dispose the writer after the rendering because the same builder can not be repeatedly used.
\par
\texttt{BlazorContext} maintains the writer and interoperability with Javascript.
It provides methods for initializing and ending the rendering.
The script represented by \texttt{ScriptInfo} is executed by its method \texttt{Evaluate}. This method accepts the context, which maintains the script output by redirecting it to the render tree.
It also allows setting superglobals like \texttt{\$\_GET} to provide the query part of URL and turns forms to client-side 
handling, which is described in the following section.

\subsection{Forms}

Forms are sent to the server by default.
We use Javascript interoperability to evaluate them on the client side.
It starts in \texttt{AfterRender} method, where we call our Javascript function, which finds all already rendered forms and assigns them an event handler for submitting.
When submit occurs, the handler collects all data from the form, does ordinary navigation to the page defined in \texttt{action} attribute, and prevents default behavior, which is sending the form to the server.
When the navigation is handled by \texttt{PhpScriptProvider}, it gets all collected data and assigns the context superglobals by them.
Afterward, the script is executed, and it can access the superglobals.
\par
In the previous paragraph, we hid the file management.
When a user loads a file by form, Javascript obtains only the information about files. 
When we want to read the content, we have to use a reading operation, which is done asynchronously by \texttt{Promise} mentioned in the Javascript section.
Thus, when we get the data during navigation, we have to wait until the content is read.
This operation could take a long time, so the page shows old content.
For this reason, we provide an additional parameter for defining the content, which is shown during navigation.
An alternative is initializing reading by a PHP script when it is executed.
It uses interoperability between PHP, C\#, and Javascript in order to call desired reading methods.
Unfortunately, Blazor does not allow us to wait until the reading operation is done, and we have to provide callbacks, which handle the end of the reading.
We suppose that it is confusing for potential PHP programmers, which will use our solution to define PHP callbacks.
We decide to prefetch the file content before the execution to provide the data synchronously in PHP code.
\par
Interoperability in the provider can be achieved in a similar manner as in \texttt{PhpComponent}.
The difference is calling the Javascript functions, which use prefined API using our context, which uses the \texttt{IJSRuntime} service.

\section{Server}

We have to set the server in order to provide additional static resources demanded by PHP scripts, as we can see in Figure \ref{img19:settings}.
The code fragment is cut from the \texttt{StartUp} class of the server.
It inserts middlewares providing the resources into the request pipeline.
Afterward, these resources can be referenced by URLs and downloaded from the server.
For example, we can reference an image with the path \texttt{Demo-PhpComponent/Asteroids/wwwroot/image.jpg} as \texttt{/Asteroids/image.jpg} in HTML document on the client side.
The second middleware provides Javascript helpers of our library to Blazor App on client side.
\par
\begin{figure}[t]
\begin{lstlisting}
var fileProvider = new ManifestEmbeddedFileProvider(
	typeof(PhpBlazor.BlazorContext).Assembly);
app.UseStaticFiles(new StaticFileOptions() { 
	FileProvider = fileProvider });

app.UseStaticFiles(new StaticFileOptions
{
	FileProvider = new PhysicalFileProvider(Path.Combine(
	Full name of parent directory, 
	"Demo-PhpComponent\\Asteroids\\wwwroot")),
	RequestPath = "/Asteroids"
});
\end{lstlisting}
\caption{Fragment of code adding middlewares.}
\label{img19:settings}
\end{figure}
            
 