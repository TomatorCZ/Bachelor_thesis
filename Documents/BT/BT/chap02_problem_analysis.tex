\chapter{Problem analysis}

We will divide the analysis into three steps.
We will think of potential users of the integration in order to define realistic use cases for them.
Four use cases will describe the user's intentions.
Then, we will specify requirements, which are demanded by the use cases.
In the last section, we will propose a high-level architecture of our solution, where we will aim at utilizing Blazor and Peachpie to content the requirements.

\section{Use Cases}
We will start by considering our stakeholders.
We can say there are two types of future users.
The first type is a PHP programmer who has no experience with Blazor.
We will call him programmer A.
The programmer creates standard websites using PHP.
The programmer's usage level of PHP is similar to what we could see in the PHP section. 
One day the programmer wants to contribute to a website powered by Blazor.
He has a great idea of adding a new feature, which can be implemented by a few PHP scripts, which use some libraries.
Unfortunately, he has never seen Blazor, and he does not want to learn the whole framework.
His point of interest is to use a solution helping him to inject his scripts into the website.
The solution should provide an effortless manual on how to inject them.
The manual should support most of the PHP conventions, which we could see in the PHP section.
\par
The second type is an enthusiastic PHP programmer who has some experience with Blazor.
We will call him programmer B.
He does not defend himself before exploring new technology to utilize all their aspects.
Again, there is an existing Blazor project, and he wants to add a new feature to it.
The PHP language offers the best way to implement it, but the feature is so render demanding that he wants to make use of a clever diff algorithm to make it more effective.
His point of interest is to use a solution offering him to collaborate with Blazor by PHP.
\par
These descriptions should help us determine the following use cases, which are realistic to both potential users.
The first use case relates to programmer A.
We can say he has a PHP website, which contains some information about his company.
The website consists of pages containing images and references interconnect them.
Some pages are adjustable by specifying a query part of the URL, and they include other scripts to add some basic layout.
One day the website becomes famous, and the programmer wants to migrate the website to a client side in order to save server resources.
The migration should download most of the website to a browser.
Afterward, navigations between scripts and a script execution should be maintained on the client side.
Even more, the programmer doesn't want to adjust the website for a client side too much, and he wishes for a simple solution that is understandable by a novice.
\par
The second use case aims at programmer A, who already has a little experience with Blazor.
There is an existing Blazor website, and he has an idea of a brilliant feature adding new functionality written in PHP.
The programmer wants to save the other developer time and also implement a UI.
Unfortunately, the feature needs to interact with a user, meaning that filling additional data, clicking, loading, and saving files.
He is lazy to learn Javascript or interoperability between PHP and Blazor.
Thus, he needs a solution, which offers interaction with a user and uses standard PHP conventions mentioned earlier.
\par
The third use case relates to programmer B.
He wants to create a real-time web game similar to Asteroids written in PHP.
The game is render demanding due to redrawing the scenes.
So he decides to target on a client side and utilizes Web API for changing the DOM tree.
This approach should prevent network latency by loading the game in the beginning.
After that, the game will be independent of the network connection due to running the game and saving the game state by a browser. 
Because he has previous experience with Blazor infrastructure, he will appreciate applying it to run this game on a client side.
Thus, he needs some representation of Blazor in PHP, which he will use for interacting with a browser.
\par
\begin{figure}[b]\centering
\includegraphics[scale=0.8]{./img/UseCaseAllTogether}
\caption{The fourth use case describing the combination of the rest.}
\label{img09:usecase}
\end{figure} 
\par
We can see an illustration of the fourth use case in figure \ref{img09:usecase}.
A goal of the use case is to allow collaboration between PHP and Blazor programmers, where a difference of languages is not a barrier.  
We can image two teams creating a web application. 
They agreed on developing a client-side web application, where both teams aim at different parts of the website.
For example, one team wants to create a fun zone where a user can play some web games and the second team wants to create some online documentation about these games.
Because Blazor targets client-side web applications, they want to utilize Blazor.
Unfortunately, these teams use a different favorite language, where the first team likes PHP and the second team likes C\#.
Even more, these teams want to arbitrarily choose what part they want to develop.
They need some environment where the PHP team can code alongside the Blazor team, and they can focus on an arbitrary part of the web application.
We can see the intention in figure \ref{img09:usecase} where each team can create a part aiming to render demanding applications, website infrastructure, and additional features.
Also, the PHP team consists of programmers having different skills with Blazor, so the environment should reflect it.

\section{Requirements}

We will define requirements based on mentioned use cases.
The question is what things should be maintained by the solution to make PHP scripts a valuable part of a Blazor website.
\par
\textbf{Navigation} is the first requirement that our solution should maintain.
We demonstrate navigation posibilities in the figure \ref{img10:scripts}.
Basic functionality should provide script routing, which finds a script by its name and executes it.
The solution should offer a straightforward router making a Php website accessible, as we can see in the figure.
A script should be injectable to a standard Blazor component due to the use case two, where the programmer injects a feature, written in PHP, to a Blazor page.
The simplicity is a necessary condition for programmer A and should be reflected.
The last option is a Blazor component in \texttt{script.php} enabling to use of already created components in PHP code.
\par
\begin{figure}[!b]\centering
\includegraphics{./img/Requirement}
\caption{Scripts should be flexible.}
\label{img10:scripts}
\end{figure} 
\par
\textbf{Rendering} should be maintained in two ways.
The first way aims at programmer A when a script output is transparently displayed as a web page or its fragment.
The approach hides Blazor infrastructure for rendering a markup and makes creating a UI easier for PHP programmers.
The second way aims at programmer B when the solution provides an interface for interacting with Blazor.
It is also necessary when we want to use already defined components in a PHP code.
\par
\textbf{State preservation} is a new feature, which should be available for creating a web application saving its state.
The example we can see in the use case 3 when we have to save the game state.
However, we should be able to choose whether it is intended behavior because scripts lose their state after every request on a server side.
\par
\textbf{Server abstraction} should be the main advantage of the solution.
We could see superglobals are commonly used methods how to obtain information about navigation or submitted data.
The solution should supports superglobals for examples like the use case 1, where the website uses information about URL query part, via \texttt{\$\_GET} variable, to make decisions.
\par
\textbf{Forms} should be maintained by the solution. 
They should not be sent to a server but parsed and provided in superglobals. 
After navigation to a script defined in the \texttt{action} attribute, the script should access the form data.
Data processing also relates to files, when it should be possible to upload and download files.
\par
\textbf{Interoperability} between PHP and Javascript should be supported for situations when forms, the server abstraction, or Blazor are not sufficient.
We should be able to call Javascript functions from PHP and vice-versa.

\section{Architecture analysis}

Blazor App is used as a cornerstone for our application.
Blazor provides the C\# migration to a browser and afterward interop with Javascript.
Peachpie transforms PHP scripts into the assembly.
The assembly can be used in Blazor App without any limitation.
Peachpie's libraries can be referenced from Blazor due to the compatibility of their target frameworks.
\par
Where to compile the scripts is the first question.
They can be regarded as static resources of the Blazor App and loaded after the Blazor's initialization.
Afterward, the Peachpie can compile them and execute them.
This approach allows us to add a PHP script during the runtime.
The second option is to compile the scripts ahead of time and reference the assembly from Blazor App.
It saves the compilation time during the runtime.
A disadvantage could be the larger size of the initial response.
The solution selects the second option.
It benefits from the compilation check on the server-side.
We suppose that the benefit is more helpful than the smaller size of the initial response.
The assembly contains the same information about the scripts, and Peachpie is intended for a static compilation.
\par
We have to figure out how to attach a PHP code, which is compiled into the assembly, to the Blazor App.
Although, we can now call functions written in PHP from Blazor.
We want to create an abstraction over the Blazor environment in order to simplify the interface.
The abstraction should offer a representation of PHP scripts in Blazor.
It should allow an option for accessing the Blazor interface for advanced features.
It should be compatible with the Blazor environment in other to allowing a smooth collaboration between the abstraction and the Blazor pages.
A Blazor page consists of components.
We can achieve collaboration by utilizing the component to represent PHP scripts.
We can benefit from a component's architecture.
Componets can be arbitrarily put together, which offers to place our PHP section in the desired place in the Razor code.
Even more, we can replace the Router with the component representing PHP scripts.
Afterward, scripts will care about the whole Blazor website's content.
The component provides a sufficient Blazor interface for rendering control and interaction with a browser. 
We can illustrate the options of usage in figure \ref{img02:component}.
\par
\begin{figure}[H]\centering
\includegraphics{./img/component}
\caption{The component representing a PHP script.}
\label{img02:component}
\end{figure} 
\par
We can think about how to represent PHP scripts as components.
There can be one type of component, which will provide the abstraction for all the PHP code in scenarios.
A problem with this approach is that the scenarios claim different levels of abstraction.
The third scenario wants to use the component for offering the Blazor interface accessible from PHP code.
The offer should contain identical or similar options, which are given in a C\# code.
The second scenario wants to use the component as an adjustable provider.
The provider finds and executes PHP scripts.
Its purpose is to keep the user away from knowing about the detailed structure of Blazor and the integration.
Another important thing is a provider's role in a Blazor App.
The provider can behave either as the Router or as a navigatable component, which enables the navigation of PHP scripts.
The conflict yields to create more types of components.
These types will provide the abstraction for the particular scenarios.
The solution will reach two types of components.
The first one wants to bring Blazor to PHP in order to utilize the whole environment.
The second one aims to present transparent executing of standard PHP script without strangeness of connection between Blazor and PHP.
\par
We will focus on the first component.
We will call the component PhpComponent due to the effort of moving the component concept to PHP.
PhpComponent aims to the third scenario.
Despite language's differences, we can utilize the common concept of classes and inheritance.
Peachpie allows inheriting C\# class in a PHP code.
This feature results in full support of component interface without creating new structures for managing component's behavior from PHP.
We can inherit ComponentBase class in PHP and use its methods in the same way as C\# class.
The inheritance offers the required interface for creating effective rendering in scenario 3.
There are also subproblems with the differences.
The current Peachpie version does not support some C\# specifics fully.
The reason can be a hard or impossible representation of C\# entities in PHP.
It should be developed some PHP support for making the usage of the interface easier.
The support will replace the missing usage of the interface.
\par
We will call the second type of component PhpScriptProvider expressing an environment for executing standard PHP scripts.
PhpScriptProvider aggregates the requirements of the rest scenarios by a single component.
Although, the provider has more than one purpose.
The main idea of serving a PHP code is the same.
The provider should be able to navigate and execute PHP scripts.
Because the rest scenarios try to hide the integration, the provider should support the following features.
It should pretend a server's behavior.
The behavior contains rendering everything, which is outside the PHP section or written by echo.
Superglobals are often used for obtaining additional information given by the user.
An ability to fill \$\_GET variable with the URL's query part should be presented.
It should change a standard Form functionality to saving the Form's information into superglobals and execute the script again.
Loading and saving files submitted by Form is essential for avoiding using Javascript.
There is an interesting thing about saving the script's context to the next execution.
These abilities are the same for the rest scenarios.
We will describe the provider's modes.
These modes are intended to solve the rest scenarios. 
\par
The first mode relates to the first scenario.
It enables to set the provider as a root component.
It handles all navigation events, determines the script's name, finds it, and executes the script.
PhpComponents can also be a navigation's target.
\par
The second mode relates to the second scenario.
It enables the provider's insertion into a Razor page.
Afterward, the provider executes the specified script.
\par
The third mode relates to the last scenario.
It enables to navigate the set of scripts with respect to URL.
The navigation is generally maintained by the default Router.
The component only provides navigation to scripts.
\par
We can see that two different components are rational ways how to separate the problems and offer an understandable difference between the components.


